{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p> Rate limiting for django using limits. </p> <p>Documentation: https://django-ratelimiter.readthedocs.io</p> <p>Sources: https://github.com/andriykohut/django-ratelimiter</p> <p>Django ratelimiter provides a decorator to wrap Django views. It relies on limits library.</p> <p>By default it uses it's own storage backend based on django cache, but it can also use storages provided by limits.</p>"},{"location":"#quickstart","title":"Quickstart","text":""},{"location":"#django-configuration","title":"Django configuration","text":"<p>With django cache storage:</p> <pre><code># Set up django caches\nCACHES = {\n    \"redis\": {\n        \"BACKEND\": \"django.core.cache.backends.redis.RedisCache\",\n        \"LOCATION\": \"redis://127.0.0.1:6379\",\n    }\n}\n\n# \"default\" cache is used if setting is not defined.\nDJANGO_RATELIMITER_CACHE = \"redis\"\n</code></pre> <p>With <code>limits</code> storage:</p> <pre><code>from limits.storage import RedisStorage\n\nDJANGO_RATELIMITER_STORAGE = RedisStorage(uri=\"redis://localhost:6379/0\")\n</code></pre>"},{"location":"#view-decorator","title":"View decorator","text":"<p>By default all requests are rate limited</p> <pre><code>from django_ratelimiter import ratelimit\n\n@ratelimit(\"5/minute\")\ndef view(request: HttpRequest) -&gt; HttpResponse:\n    return HttpResponse(\"OK\")\n</code></pre> <p>Per-user limits (using request attribute key)</p> <pre><code>@ratelimit(\"5/minute\", key=\"user\")\ndef view(request: HttpRequest) -&gt; HttpResponse:\n    return HttpResponse(\"OK\")\n</code></pre> <p>Callable key can be used to define more complex rules</p> <pre><code>@ratelimit(\"5/minute\", key=lambda r: r.user.username)\ndef view(request: HttpRequest) -&gt; HttpResponse:\n    return HttpResponse(\"OK\")\n</code></pre> <p>Define which HTTP methods to rate limit</p> <pre><code>@ratelimit(\"5/minute\", methods=[\"POST\", \"PUT\"])\ndef view(request):\n    return HttpResponse(\"OK\")\n</code></pre> <p>Custom response:</p> <pre><code>from django.http import HttpResponse\n\n@ratelimit(\"5/minute\", response=HttpResponse(\"Too many requests\", status=400))\ndef view(request):\n    return HttpResponse(\"OK\")\n</code></pre> <p>Per-view storage:</p> <pre><code>from limits.storage import RedisStorage\n\n@ratelimit(\"5/minute\", storage=RedisStorage(uri=\"redis://localhost:6379/0\"))\ndef view(request):\n    return HttpResponse(\"OK\")\n</code></pre>"},{"location":"api_reference/","title":"API Reference","text":""},{"location":"api_reference/#django_ratelimiter.decorator","title":"django_ratelimiter.decorator","text":""},{"location":"api_reference/#django_ratelimiter.decorator.build_identifiers","title":"build_identifiers","text":"<pre><code>build_identifiers(func: ViewFunc, methods: Union[str, Sequence[str], None] = None) -&gt; list[str]\n</code></pre> <p>Build view identifiers for storage cache key using function signature and list of methods.</p> Source code in <code>django_ratelimiter/decorator.py</code> <pre><code>def build_identifiers(\n    func: ViewFunc, methods: Union[str, Sequence[str], None] = None\n) -&gt; list[str]:\n    \"\"\"Build view identifiers for storage cache key using function signature and list of methods.\"\"\"\n    if isinstance(func, partial):\n        # method_decorator scenario\n        identifiers = [\n            func.func.__self__.__class__.__module__,\n            f\"{func.func.__self__.__class__.__qualname__}.{func.func.__name__}\",\n        ]\n    else:\n        identifiers = [func.__module__, func.__qualname__]\n    if methods:\n        methods_ = methods if isinstance(methods, str) else \"|\".join(sorted(methods))\n        identifiers.append(methods_)\n    return identifiers\n</code></pre>"},{"location":"api_reference/#django_ratelimiter.decorator.get_rate_limiter","title":"get_rate_limiter","text":"<pre><code>get_rate_limiter(strategy: str, storage: Optional[Storage] = None) -&gt; RateLimiter\n</code></pre> <p>Return a ratelimiter instance for given strategy.</p> Source code in <code>django_ratelimiter/decorator.py</code> <pre><code>def get_rate_limiter(strategy: str, storage: Optional[Storage] = None) -&gt; RateLimiter:\n    \"\"\"Return a ratelimiter instance for given strategy.\"\"\"\n    if strategy not in STRATEGIES:\n        raise ValueError(\n            f\"Unknown strategy {strategy}, must be one of {STRATEGIES.keys()}\"\n        )\n    storage = storage or get_storage()\n    return STRATEGIES[strategy](storage)\n</code></pre>"},{"location":"api_reference/#django_ratelimiter.decorator.get_storage","title":"get_storage","text":"<pre><code>get_storage() -&gt; Storage\n</code></pre> <p>Returns a default storage backend instance, defined by either <code>DJANGO_RATELIMITER_CACHE</code> or <code>DJANGO_RATELIMITER_STORAGE</code>.</p> Source code in <code>django_ratelimiter/decorator.py</code> <pre><code>def get_storage() -&gt; Storage:\n    \"\"\"Returns a default storage backend instance, defined by either `DJANGO_RATELIMITER_CACHE`\n    or `DJANGO_RATELIMITER_STORAGE`.\"\"\"\n    cache_name: Optional[str] = getattr(settings, \"DJANGO_RATELIMITER_CACHE\", None)\n    storage: Optional[Storage] = getattr(settings, \"DJANGO_RATELIMITER_STORAGE\", None)\n    if cache_name and storage:\n        raise ValueError(\n            \"DJANGO_RATELIMITER_CACHE and DJANGO_RATELIMITER_STORAGE can't be used together\"\n        )\n    return storage or CacheStorage(cache_name or \"default\")\n</code></pre>"},{"location":"api_reference/#django_ratelimiter.decorator.ratelimit","title":"ratelimit","text":"<pre><code>ratelimit(\n    rate: Union[str, Callable[[HttpRequest], str]],\n    key: Union[str, Callable[[HttpRequest], str], None] = None,\n    methods: Union[str, Sequence[str], None] = None,\n    strategy: Literal[\n        \"fixed-window\", \"fixed-window-elastic-expiry\", \"moving-window\"\n    ] = \"fixed-window\",\n    response: Optional[HttpResponse] = None,\n    storage: Optional[Storage] = None,\n    cache: Optional[str] = None,\n) -&gt; Callable[[ViewFunc], ViewFunc]\n</code></pre> <p>Rate limiting decorator for wrapping views.</p> <p>Parameters:</p> Name Type Description Default <code>rate</code> <code>Union[str, Callable[[HttpRequest], str]]</code> <p>rate string (i.e. <code>5/second</code>) or a callable that takes a request and returns a rate</p> required <code>key</code> <code>Union[str, Callable[[HttpRequest], str], None]</code> <p>request attribute or callable that returns a string to be used as identifier</p> <code>None</code> <code>methods</code> <code>Union[str, Sequence[str], None]</code> <p>only rate limit specified method(s)</p> <code>None</code> <code>strategy</code> <code>Literal['fixed-window', 'fixed-window-elastic-expiry', 'moving-window']</code> <p>a name of rate limiting strategy</p> <code>'fixed-window'</code> <code>response</code> <code>Optional[HttpResponse]</code> <p>custom rate limit response instance</p> <code>None</code> <code>storage</code> <code>Optional[Storage]</code> <p>override default rate limit storage</p> <code>None</code> <code>cache</code> <code>Optional[str]</code> <p>override default cache name if using django cache storage backend</p> <code>None</code> Source code in <code>django_ratelimiter/decorator.py</code> <pre><code>def ratelimit(\n    rate: Union[str, Callable[[HttpRequest], str]],\n    key: Union[str, Callable[[HttpRequest], str], None] = None,\n    methods: Union[str, Sequence[str], None] = None,\n    strategy: Literal[\n        \"fixed-window\",\n        \"fixed-window-elastic-expiry\",\n        \"moving-window\",\n    ] = \"fixed-window\",\n    response: Optional[HttpResponse] = None,\n    storage: Optional[Storage] = None,\n    cache: Optional[str] = None,\n) -&gt; Callable[[ViewFunc], ViewFunc]:\n    \"\"\"Rate limiting decorator for wrapping views.\n\n    Arguments:\n        rate: rate string (i.e. `5/second`) or a callable that takes a request and returns a rate\n        key: request attribute or callable that returns a string to be used as identifier\n        methods: only rate limit specified method(s)\n        strategy: a name of rate limiting strategy\n        response: custom rate limit response instance\n        storage: override default rate limit storage\n        cache: override default cache name if using django cache storage backend\n    \"\"\"\n    if storage and cache:\n        raise ValueError(\"Can't use both cache and storage\")\n    rate_limiter = get_rate_limiter(strategy, storage)\n\n    def decorator(func: ViewFunc) -&gt; ViewFunc:\n        @wraps(func)\n        def wrapper(\n            request: HttpRequest, *args: P.args, **kwargs: P.kwargs\n        ) -&gt; HttpResponse:\n            rate_str = rate(request) if callable(rate) else rate\n            parsed_rate = parse(rate_str)\n            if getattr(settings, \"DJANGO_RATELIMITER_CACHE\", True) and (\n                not methods or request.method in methods\n            ):\n                identifiers = build_identifiers(func, methods)\n\n                if key:\n                    value = key(request) if callable(key) else getattr(request, key)\n                    value = str(value.pk if isinstance(value, models.Model) else value)\n                    identifiers.append(value)\n\n                if not rate_limiter.hit(parsed_rate, *identifiers):\n                    return response or HttpResponse(\n                        \"Too Many Requests\",\n                        status=429,\n                    )\n            return func(request, *args, **kwargs)\n\n        return wrapper\n\n    return decorator\n</code></pre>"},{"location":"api_reference/#django_ratelimiter.storage","title":"django_ratelimiter.storage","text":""},{"location":"api_reference/#django_ratelimiter.storage.CacheStorage","title":"CacheStorage","text":"<p>             Bases: <code>Storage</code></p> <p>Rate limiting storage with django cache backend.</p> Source code in <code>django_ratelimiter/storage.py</code> <pre><code>class CacheStorage(Storage):\n    \"\"\"Rate limiting storage with django cache backend.\"\"\"\n\n    def __init__(\n        self,\n        cache: str,\n        wrap_exceptions: bool = False,\n        **options: Union[float, str, bool],\n    ) -&gt; None:\n        self.cache: BaseCache = caches[cache]\n        super().__init__(uri=None, wrap_exceptions=wrap_exceptions, **options)\n\n    @property\n    def base_exceptions(self) -&gt; Union[type[Exception], tuple[type[Exception], ...]]:\n        return Exception\n\n    def get(self, key: str) -&gt; int:\n        return self.cache.get(key, 0)\n\n    def incr(\n        self, key: str, expiry: int, elastic_expiry: bool = False, amount: int = 1\n    ) -&gt; int:\n        self.cache.get_or_set(key, 0, expiry)\n        self.cache.get_or_set(f\"{key}/expires\", time.time() + expiry, expiry)\n        try:\n            value = self.cache.incr(key, amount) or amount\n        except ValueError:\n            value = amount\n        if elastic_expiry:\n            self.cache.touch(key, expiry)\n            self.cache.set(f\"{key}/expires\", time.time() + expiry, expiry)\n        return value\n\n    def get_expiry(self, key: str) -&gt; int:\n        return int(float(self.cache.get(key + \"/expires\") or time.time()))\n\n    def check(self) -&gt; bool:\n        try:\n            self.cache.get(\"django-ratelimiter-check\")\n            return True\n        except:  # noqa: E722\n            return False\n\n    def reset(self) -&gt; Optional[int]:\n        raise NotImplementedError\n\n    def clear(self, key: str) -&gt; None:\n        self.cache.delete(key)\n</code></pre>"},{"location":"api_reference/#django_ratelimiter.types.P","title":"django_ratelimiter.types.P  <code>module-attribute</code>","text":"<pre><code>P = ParamSpec('P')\n</code></pre>"},{"location":"api_reference/#django_ratelimiter.types.ViewFunc","title":"django_ratelimiter.types.ViewFunc  <code>module-attribute</code>","text":"<pre><code>ViewFunc = Callable[Concatenate[HttpRequest, P], HttpResponse]\n</code></pre>"}]}